---
import { ConnectFourWasm } from "../../../../../packages/connect_four_rust/index";
import JSONCrush from "jsoncrush";
import { z } from "zod";
import { memoize } from "lodash-es";
import Layout from "../../layouts/Layout.astro";

// Define your Zod schemas
const CellSchema = z.union([
  z.literal("Empty"),
  z.object({ Filled: z.enum(["Red", "Yellow"]) }),
]);

const GameStateSchema = z.object({
  board: z.array(z.array(CellSchema)),
  current_player: z.enum(["Red", "Yellow"]),
  is_game_over: z.boolean(),
  winner: z.enum(["Red", "Yellow"]).nullable().optional(),
});

const ExtendedGameStateSchema = GameStateSchema.extend({
  newestPieceColumn: z.number().nullable(),
  newestComputerPieceColumn: z.number().nullable(),
  minimaxQuality: z.enum(["bad", "medium", "best"]),
});

type ExtendedGameState = z.infer<typeof ExtendedGameStateSchema>;

// Define the base URL
const baseURL = `${Astro.url.protocol}//${Astro.url.host}`;
console.log(baseURL);
// Initialize the WASM module with the base URL
await ConnectFourWasm.init(baseURL);

// Access the URL search parameters

const stateParam = Astro.url.searchParams.get("state");

// Measure computation time
const timeStart = Date.now();

const initialState: ExtendedGameState = {
  ...ConnectFourWasm.create_initial_state(),
  newestPieceColumn: null,
  newestComputerPieceColumn: null,
  minimaxQuality: "best",
};

let gameState: ExtendedGameState;

try {
  if (stateParam) {
    const parsedState = JSON.parse(JSONCrush.uncrush(stateParam)) as unknown;

    gameState = ExtendedGameStateSchema.parse(parsedState);
  } else {
    gameState = initialState;
  }
} catch (error) {
  console.error("Invalid game state:", error);
  gameState = initialState;
}

// Compute the computer's move if it's the computer's turn
const moveStart = Date.now();
let moveComputedIn = 0;
if (!gameState.is_game_over && gameState.current_player === "Yellow") {
  const computerMove = ConnectFourWasm.get_computer_move(
    gameState,
    gameState.minimaxQuality
  );
  moveComputedIn = Date.now() - moveStart;
  const computerState = ConnectFourWasm.place_piece(gameState, computerMove);
  gameState = {
    ...computerState,
    newestPieceColumn: gameState.newestPieceColumn,
    minimaxQuality: gameState.minimaxQuality,
    newestComputerPieceColumn: computerMove,
  };
}

const {
  board,
  current_player,
  is_game_over,
  winner,
  newestPieceColumn,
  newestComputerPieceColumn,
} = gameState;

const getNextState = memoize((column: number): ExtendedGameState => {
  if (is_game_over) return gameState;

  // Player's move (red)
  const playerState = ConnectFourWasm.place_piece(gameState, column);
  const playerExtendedState: ExtendedGameState = {
    ...playerState,
    minimaxQuality: gameState.minimaxQuality,
    newestPieceColumn: column,
    newestComputerPieceColumn: null, // Reset the computer's newest piece
  };

  return playerExtendedState;
});

function renderCell(
  cell: z.infer<typeof CellSchema>,
  rowIndex: number,
  colIndex: number
) {
  const cellColor =
    cell === "Empty"
      ? "bg-white"
      : cell.Filled === "Red"
        ? "bg-red-500"
        : "bg-yellow-500";

  let animationClass = "";
  if (newestPieceColumn != null) {
    const pieceRow = board[newestPieceColumn]?.findIndex(
      (cell) => cell !== "Empty"
    );
    if (pieceRow != null) {
      const isNewColumn = colIndex === newestPieceColumn;
      const isNewPiece = isNewColumn && rowIndex === 5 - pieceRow;
      if (isNewPiece) {
        animationClass = "animate-slide-down";
      }
    }
  }

  if (newestComputerPieceColumn != null) {
    const computerPieceRow = board[newestComputerPieceColumn]?.findIndex(
      (cell) => cell !== "Empty"
    );
    if (computerPieceRow != null) {
      const isNewComputerColumn = colIndex === newestComputerPieceColumn;
      const isNewComputerPiece =
        isNewComputerColumn && rowIndex === 5 - computerPieceRow;
      if (isNewComputerPiece) {
        animationClass = "animate-computer-slide-down";
      }
    }
  }

  const cellContent = `<div class="absolute inset-0 rounded-full border-2 border-gray-300 ${cellColor} ${animationClass}"></div>`;

  if (cell === "Empty" && !is_game_over) {
    const nextState = getNextState(colIndex);
    const compressedState = JSONCrush.crush(JSON.stringify(nextState));
    const href = `/connect-four-wasm?state=${encodeURIComponent(compressedState)}`;
    return `
      <a href="${href}">
        <div class="relative h-12 w-12 cursor-pointer rounded-full">
          <div class="absolute inset-0 rounded-full bg-white"></div>
          ${cellContent}
        </div>
      </a>
    `;
  }

  return `
    <div class="relative h-12 w-12">
      <div class="absolute inset-0 rounded-full bg-white"></div>
      ${cellContent}
    </div>
  `;
}

function renderQualityLink(quality: "bad" | "medium" | "best") {
  const newState: ExtendedGameState = {
    ...gameState,
    minimaxQuality: quality,
  };
  const compressedState = JSONCrush.crush(JSON.stringify(newState));
  const isActive = gameState.minimaxQuality === quality;
  const href = `/connect-four-wasm?state=${encodeURIComponent(compressedState)}`;

  const className = isActive
    ? "bg-blue-500 text-white"
    : "bg-white text-blue-500 hover:bg-blue-100";

  return `
    <a href="${href}" class="mx-1 rounded px-3 py-1 text-sm font-medium ${className}">
      ${quality.charAt(0).toUpperCase() + quality.slice(1)}
    </a>
  `;
}

function renderEngineToggle() {
  // Convert WASM state back to TypeScript format
  const tsState = {
    board: gameState.board.map((column) =>
      column.map((cell) =>
        cell === "Empty"
          ? null
          : (cell.Filled.toLowerCase() as "red" | "yellow")
      )
    ),
    currentPlayer: gameState.current_player.toLowerCase() as "red" | "yellow",
    isGameOver: gameState.is_game_over,
    winner: gameState.winner
      ? (gameState.winner.toLowerCase() as "red" | "yellow")
      : null,
    newestPieceColumn: gameState.newestPieceColumn,
    newestComputerPieceColumn: gameState.newestComputerPieceColumn,
    minimaxQuality: gameState.minimaxQuality,
  };

  const compressedTsState = JSONCrush.crush(JSON.stringify(tsState));
  const compressedWasmState = JSONCrush.crush(JSON.stringify(gameState));

  return `
    <div class="mt-4 flex items-center">
      <span class="mr-2">Engine:</span>
      <a
        href="/?state=${encodeURIComponent(compressedTsState)}"
        class="mx-1 rounded bg-white px-3 py-1 text-sm font-medium text-blue-500 hover:bg-blue-100"
      >
        TypeScript
      </a>
      <a
        href="/connect-four-wasm?state=${encodeURIComponent(compressedWasmState)}"
        class="mx-1 rounded bg-blue-500 px-3 py-1 text-sm font-medium text-white"
      >
        WASM
      </a>
    </div>
  `;
}

function generatePrefetchLinks() {
  if (is_game_over) return "";

  return Array.from({ length: 7 }, (_, colIndex) => {
    const nextState = getNextState(colIndex);
    const compressedState = JSONCrush.crush(JSON.stringify(nextState));
    const url = `/connect-four-wasm?state=${encodeURIComponent(compressedState)}`;
    return `<link rel="prefetch" href="${url}">`;
  }).join("\n");
}
---

<Layout title="Connect Four (WASM)">
  <Fragment slot="head">
    <Fragment set:html={generatePrefetchLinks()} />
  </Fragment>

  <!-- HTML Template -->
  <div
    class="flex min-h-screen flex-col items-center justify-center bg-gray-100"
  >
    <h1 class="mb-8 text-4xl font-bold">Connect Four (WASM)</h1>
    <div class="rounded-lg bg-blue-500 p-4">
      <div class="grid grid-cols-7 gap-1">
        {
          board.map((column, colIndex) => (
            <div class="flex flex-col hover:opacity-50">
              {column.map((cell, rowIndex) => (
                <div set:html={renderCell(cell, 5 - rowIndex, colIndex)} />
              ))}
            </div>
          ))
        }
      </div>
    </div>
    {
      is_game_over && (
        <div class="mt-4 text-xl font-semibold">
          {winner ? `${winner.toUpperCase()} wins!` : "It's a draw!"}
        </div>
      )
    }
    {
      !is_game_over && (
        <div class="mt-4 text-xl font-semibold">
          Current player: {current_player.toUpperCase()}
        </div>
      )
    }
    <small>Page constructed in {Date.now() - timeStart}ms</small>
    <small>Computer move computed in {moveComputedIn}ms</small>
    <div class="mt-4">
      <span class="mr-2">CPU Quality:</span>
      <Fragment set:html={renderQualityLink("bad")} />
      <Fragment set:html={renderQualityLink("medium")} />
      <Fragment set:html={renderQualityLink("best")} />
    </div>
    <Fragment set:html={renderEngineToggle()} />
    <a
      href="/connect-four-wasm"
      class="mt-8 rounded bg-blue-500 px-4 py-2 text-white hover:bg-blue-600"
    >
      New Game
    </a>
  </div>

  <style is:global>
    @tailwind base;
    @tailwind components;
    @tailwind utilities;

    @keyframes slideDown {
      from {
        transform: translateY(-400%);
      }

      to {
        transform: translateY(0);
      }
    }

    @keyframes computerSlideDown {
      0% {
        transform: translateY(-12000%);
        opacity: 0;
      }
      50% {
        transform: translateY(-600%);
        opacity: 100%;
      }
      100% {
        transform: translateY(0);
      }
    }

    @layer utilities {
      .animate-slide-down {
        animation: slideDown 0.2s ease-in;
      }

      .animate-computer-slide-down {
        animation: computerSlideDown 0.8s ease-in;
      }
    }
  </style>
</Layout>
